<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>2d-getColor</title>
  <style>
canvas {
      width: 0px;
    }
    .result {
      display: grid;
      grid-template-columns: repeat(auto-fill,minmax(320px,1fr));
      gap: 4px;
    }
    .result > img {
      grid-row-start: 1;
      grid-row-end: 10;
    }
  </style>
</head>
<body>
  <h1>中位切割法获取图片颜色主要颜色</h1>
  <pre>
    使用中位切分法(将所有像素映射到三维坐标上(r,g,b))
    获取图片所有像素  canvas 的 getImageData
    计算边界 rmax gmax bmax rmin gmin bmin, 代表包裹像素分布区域的长宽高
    从维度最大的轴来做中位切割
    按照上述重复切割
    //第一个是平均色
    //按色块所包含像素数量从大到小排
    //画入canvas是 200*200, 所以总像素为4w
    色块数量按 2 4 8 16 来, 目前默认为8
    计算所有色块的平均值作为当前色块的代表色
    最后,将结果色块从rgb转为Lab,计算差值,差值小于40定义为相似颜色,合并颜色,获取到图片主色调
    <a href="https://blog.csdn.net/yuzi_lixiaoge/article/details/52781506">rgb 转 Lab</a>
    <a href="http://www.colormine.org/delta-e-calculator">颜色相似度计算</a>
    <a href="https://stackoverflow.com/questions/5392061/algorithm-to-check-similarity-of-colors">关于颜色相似的处理链接</a> 
  </pre>
  <input type="file">
  <canvas width="300" height="200">如果看到这句话说明浏览器不支持canvas</canvas>
  <div class="result"></div>
  <script>

    const count = 8

    let result = []

    let colors = []   //颜色

    const input = document.getElementsByTagName('input')[0]

    const ctx = document.getElementsByTagName('canvas')[0].getContext('2d')

    const resultDiv = document.getElementsByTagName('div')[0]

    let imgUrl

    //清除选中的文件
    function removeFile() {
      input.outerHTML = input.outerHTML
    }

    //使用createObjectURl来获取图片地址(也可以使用FileReader)
    function getObjectURL(file) {
      let url = null ;
      if (window.createObjectURL!=undefined) { // basic
        url = window.createObjectURL(file) 
      } else if (window.URL!=undefined) { // mozilla(firefox)
        url = window.URL.createObjectURL(file) 
      } else if (window.webkitURL!=undefined) { // webkit or chrome
        url = window.webkitURL.createObjectURL(file) 
      }
	    return url 
    }

    //移除生成的图片地址
    function removeObjectURL() {
      if (window.revokeObjectURL!=undefined) { // basic
        imgUrl = window.revokeObjectURL(imgUrl) 
      } else if (window.URL!=undefined) { // mozilla(firefox)
        imgUrl = window.URL.revokeObjectURL(imgUrl) 
      } else if (window.webkitURL!=undefined) { // webkit or chrome
        imgUrl = window.webkitURL.revokeObjectURL(imgUrl) 
      }
    }

    //画到canvas里
    function drawToCanvas() {
      const img = new Image(320)
      img.onload = function() {
        ctx.drawImage(img,0,0,200,200)
        const pixels = getPixels()
        slicePixels(pixels) 
        repeatSlicePixels(result.length)
        result.sort((a,b) => b.length - a.length) //降序
        // console.log(result)
        result.forEach(data => {
          let accR = 0, accG = 0, accB = 0
          let len = data.length
          data.forEach(item => {
            accR += item['r']
            accG += item['g']
            accB += item['b']
          })
          const r = Math.round(accR/len)
          const g = Math.round(accG/len)
          const b = Math.round(accB/len)
          const bgColor = `rgb(${r},${g},${b})`
          colors.push({
            len,
            lab: rgbToLab(r,g,b),      
            rgb: [r,g,b],
            index: 1         //表示累计,默认1
          })
          createDiv(bgColor)
        })
        //将颜色转换成Lab,进行deltaE计算,差值目前决定在30之内
        // console.log(colors)
        combineColors()
        const mainColor = getMainColor()
        // createDiv(mainColor)
        document.body.style.backgroundColor = mainColor
      }
      img.src = imgUrl
      resultDiv.appendChild(img)
    }

    //获取主色调
    function getMainColor() {
      let max = 0, maxIndex = 0
      colors.forEach((color,index) => {
        if(color['len'] > max) {
          max = color['len']
          maxIndex = index
        }
      })
      const r = colors[maxIndex]['rgb'][0]
      const g = colors[maxIndex]['rgb'][1]
      const b = colors[maxIndex]['rgb'][2]
      const len = colors[maxIndex]['index']
      return `rgb(${r/len},${g/len},${b/len},0.8)`
    }

    //合并颜色
    function combineColors() {
      for(let i = 0;i < colors.length;i++) {
        for(let j = i + 1;j < colors.length;j++) {
          const diff = deltaE(colors[i]['lab'],colors[j]['lab'])
          if(diff <= 40) {
            colors[i]['len'] += colors[j]['len']
            colors[i]['rgb'][0] += colors[j]['rgb'][0]
            colors[i]['rgb'][1] += colors[j]['rgb'][1]
            colors[i]['rgb'][2] += colors[j]['rgb'][2]
            colors[i]['index']++
            colors.splice(j,1)
          }
        }
      }
    }

    //deltaE
    function deltaE(color1,color2) {
      // (l2-l1)
      const l = Math.pow(color2[0] - color1[0],2)
      const a = Math.pow(color2[1] - color1[1],2)
      const b = Math.pow(color2[2] - color1[1],2)
      return Math.sqrt(l + a + b)
    }

    //rgb 转 Lab
    function rgbToLab(r, g, b) {
      r /= 255, g /= 255, b /= 255;
      if ( r > 0.04045 ){
			  r = Math.pow(( r + 0.055 ) / 1.055, 2.4);
      } else {
        r = r / 12.92;
      }
      if ( g > 0.04045 ){
        g = Math.pow(( g + 0.055 ) / 1.055, 2.4);
      } else {
        g = g / 12.92;
      }
      if ( b > 0.04045 ){
        b = Math.pow(( b + 0.055 ) / 1.055, 2.4);
      } else {
        b = b / 12.92;
      }
      // sRGB
      let X = r * 0.436052025 + g * 0.385081593 + b * 0.143087414;
      let Y = r * 0.222491598 + g * 0.716886060 + b * 0.060621486;
      let Z = r * 0.013929122 + g * 0.097097002 + b * 0.714185470;
      // XYZ range: 0~100
      X = X * 100.000;
      Y = Y * 100.000;
      Z = Z * 100.000;
      // Reference White Point
      let ref_X = 96.4221;
      let ref_Y = 100.000;
      let ref_Z = 82.5211;
      X = X / ref_X;
      Y = Y / ref_Y;
      Z = Z / ref_Z;
      // Lab
      if (X > 0.008856){
        X = Math.pow(X, 1/3.000);
      } else {
        X = ( 7.787 * X ) + ( 16 / 116.000 );
      }
      if (Y > 0.008856){
        Y = Math.pow(Y, 1/3.000);
      } else {
        Y = ( 7.787 * Y ) + ( 16 / 116.000 );
      }
      if (Z > 0.008856){
        Z = Math.pow(Z, 1/3.000);
      } else {
        Z = ( 7.787 * Z ) + ( 16 / 116.000 );
      }
  
      let lab_L = ( 116.000 * Y ) - 16.000;
      let lab_A = 500.000 * ( X - Y );
      let lab_B = 200.000 * ( Y - Z );
  
      return [lab_L, lab_A , lab_B];

    }

    //生成色块
    function createDiv(bgColor) {
      const div = document.createElement('div')
      Object.assign(div.style,{
        backgroundColor: bgColor,
        height: '50px',
      })
      resultDiv.appendChild(div)
    }

    //切割像素
    function slicePixels(pixels,tag) {
      let rmax, rmin, gmax, gmin, bmax, bmin
      pixels.forEach(pixel => {
        const r = pixel['r']
        const g = pixel['g']
        const b = pixel['b']
        rmax = getMaxBoundary(rmax,r)
        rmin = getMinBoundary(rmin,r)
        gmax = getMaxBoundary(gmax,g) 
        gmin = getMinBoundary(gmin,g)
        bmax = getMaxBoundary(bmax,b) 
        bmin = getMinBoundary(bmin,b)
      })
      const median = getMedian(rmax,rmin,gmax,gmin,bmax,bmin)
      const block1 = [], block2 = []
      pixels.forEach(pixel => {
        if(pixel[median['key']] >= median['value']) {
          block1.push(pixel)
        }else{
          block2.push(pixel)
        }
      })
      result.push(block1,block2)
    }

    //重复切割
    function repeatSlicePixels(len) {
      if(len < count) {
        result.forEach(data => slicePixels(data)) //等价于for(let i = 0;i<len-1;i++)
        result.splice(0,len)
        repeatSlicePixels(result.length)
      }
    }

    //获取像素点
    function getPixels() {
      const { data } = ctx.getImageData(0,0,200,200)
      // const pixel = {r,g,b,a}
      const pixels = []
      let r = 0, g = 0, b = 0
      for(let i = 0;i < data.length;i += 4) {
        const pixel = {}
        r += pixel['r'] = data[i]
        g += pixel['g'] = data[i+1]
        b += pixel['b'] = data[i+2]
        // pixel['a'] = data[i+3]
        pixels.push(pixel)
      }
      const len = pixels.length
      const bgColor = `rgb(${Math.round(r/len)},${Math.round(g/len)},${Math.round(b/len)})`
      createDiv(bgColor) //平均色
      return pixels
    }

    //获取边界(最大最小rgb)
    function getMaxBoundary(max,diff) {
      if(max === undefined) return diff
      return Math.max(max,diff)
    }
    function getMinBoundary(min,diff) {
      if(min === undefined) return diff
      return Math.min(min,diff)
    }

    //获取中位线
    function getMedian(rmax,rmin,gmax,gmin,bmax,bmin) {
      const r = rmax - rmin
      const g = gmax - gmin
      const b = bmax - bmin
      const max = Math.max(r,g,b)
      if(r === max) return {key:'r',value:(rmax + rmin)/2}
      if(g === max) return {key:'g',value:(gmax + gmin)/2}
      if(b === max) return {key:'b',value:(bmax + bmin)/2}
    }

    //判断是否图片
    function isImg(fileName) {
      const pattern = /\.(jpg|jpeg|png|GIF|JPG|PNG)$/
      if (pattern.test(fileName) ) return  true
      alert('请选择图片文件')
	    return false
    }

    input.onchange = function(e) {
      const file = e.target.files[0]
      if(isImg(file.name)) {
        if(imgUrl) {
          removeObjectURL()
          result = []
          colors = []
          resultDiv.innerHTML = ''
        }
        imgUrl = getObjectURL(file)
        drawToCanvas()
      }
    }

  </script>
</body>
</html>
