<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>2d-getColor</title>
  <style>
    canvas {
      width: 300px;
      height: 200px;
      display: none;
    }
    .result > img {
      float: left;
    }
    .result > div {
      margin-left: 320px;
    }
    @media screen and (max-width:500px) {
      .result > img {
        float: none;
      }
      .result > div {
        margin-left: 0;
      }
    }
  </style>
</head>
<body>
  <h1>中位切割法获取图片颜色主要颜色</h1>
  <pre>
    使用中位切分法(将所有像素映射到三维坐标上(r,g,b))
    获取图片所有像素  canvas 的 getImageData
    计算边界 rmax gmax bmax rmin gmin bmin, 代表包裹像素分布区域的长宽高
    从维度最大的轴来做中位切割
    按照上述重复切割
    //4个色块切3次
    //8个色块切7次
    //按色块所包含像素数量从大到小排
    色块数量只能按 2 4 8 16 来, 目前默认为8
    计算所有色块的平均值作为当前色块的代表色
  </pre>
  <input type="file">
  <canvas width="300" height="200">如果看到这句话说明浏览器不支持canvas</canvas>
  <div class="result"></div>
  <script>

    const count = 8

    let result = []

    const input = document.getElementsByTagName('input')[0]

    const ctx = document.getElementsByTagName('canvas')[0].getContext('2d')

    const resultDiv = document.getElementsByTagName('div')[0]

    let imgUrl

    //清除选中的文件
    function removeFile() {
      input.outerHTML = input.outerHTML
    }

    //使用createObjectURl来获取图片地址(也可以使用FileReader)
    function getObjectURL(file) {
      let url = null ;
      if (window.createObjectURL!=undefined) { // basic
        url = window.createObjectURL(file) 
      } else if (window.URL!=undefined) { // mozilla(firefox)
        url = window.URL.createObjectURL(file) 
      } else if (window.webkitURL!=undefined) { // webkit or chrome
        url = window.webkitURL.createObjectURL(file) 
      }
	    return url 
    }

    //移除生成的图片地址
    function removeObjectURL() {
      if (window.revokeObjectURL!=undefined) { // basic
        imgUrl = window.revokeObjectURL(imgUrl) 
      } else if (window.URL!=undefined) { // mozilla(firefox)
        imgUrl = window.URL.revokeObjectURL(imgUrl) 
      } else if (window.webkitURL!=undefined) { // webkit or chrome
        imgUrl = window.webkitURL.revokeObjectURL(imgUrl) 
      }
    }

    //画到canvas里
    function drawToCanvas() {
      const img = new Image(320)
      img.onload = function() {
        ctx.drawImage(img,0,0,200,200)
        const pixels = getPixels()
        slicePixels(pixels)
        const len = result.length
        repeatSlicePixels(len)
        result.sort((a,b) => b.length - a.length) //降序
        result.forEach(data => {
          let accR = 0, accG = 0, accB = 0
          let len = data.length
          data.forEach(item => {
            accR += item['r']
            accG += item['g']
            accB += item['b']
          })
          const div = document.createElement('div')
          Object.assign(div.style,{
            backgroundColor: `rgb(${Math.floor(accR/len)},${Math.floor(accG/len)},${Math.floor(accB/len)})`,
            height: '50px',
          })
          resultDiv.appendChild(div)
        })
      }
      img.src = imgUrl
      resultDiv.appendChild(img)
    }

    //切割像素
    function slicePixels(pixels,tag) {
      let rmax, rmin, gmax, gmin, bmax, bmin
      pixels.forEach(pixel => {
        const r = pixel['r']
        const g = pixel['g']
        const b = pixel['b']
        rmax = getMaxBoundary(rmax,r)
        rmin = getMinBoundary(rmin,r)
        gmax = getMaxBoundary(gmax,g) 
        gmin = getMinBoundary(gmin,g)
        bmax = getMaxBoundary(bmax,b) 
        bmin = getMinBoundary(bmin,b)
      })
      const median = getMedian(rmax,rmin,gmax,gmin,bmax,bmin)
      const block1 = [], block2 = []
      pixels.forEach(pixel => {
        if(pixel[median['key']] >= median['value']) {
          block1.push(pixel)
        }else{
          block2.push(pixel)
        }
      })
      if(block1.length === 0 || block2.length === 0) console.log(median,rmax,rmin,gmax,gmin,bmax,bmin)
      result.push(block1,block2)
    }

    //重复切割
    function repeatSlicePixels(len) {
      if(len < count) {
        result.forEach(data => slicePixels(data)) //等价于for(let i = 0;i<len-1;i++)
        result.splice(0,len)
        repeatSlicePixels(result.length)
      }
    }

    //获取像素点
    function getPixels() {
      const { data } = ctx.getImageData(0,0,200,200)
      // const pixel = {r,g,b,a}
      const pixels = []
      for(let i = 0;i < data.length;i += 4) {
        const pixel = {}
        pixel['r'] = data[i]
        pixel['g'] = data[i+1]
        pixel['b'] = data[i+2]
        // pixel['a'] = data[i+3]
        pixels.push(pixel)
      }
      return pixels
    }

    //获取边界(最大最小rgb)
    function getMaxBoundary(max,diff) {
      if(max === undefined) return diff
      return Math.max(max,diff)
    }
    function getMinBoundary(min,diff) {
      if(min === undefined) return diff
      return Math.min(min,diff)
    }

    //获取中位线
    function getMedian(rmax,rmin,gmax,gmin,bmax,bmin) {
      const r = rmax - rmin
      const g = gmax - gmin
      const b = bmax - bmin
      const max = Math.max(r,g,b)
      if(r === max) return {key:'r',value:(rmax + rmin)/2}
      if(g === max) return {key:'g',value:(gmax + gmin)/2}
      if(b === max) return {key:'b',value:(bmax + bmin)/2}
    }

    //判断是否图片
    function isImg(fileName) {
      const pattern = /\.(jpg|jpeg|png|GIF|JPG|PNG)$/
      if (pattern.test(fileName) ) return  true
      alert('请选择图片文件')
	    return false
    }

    input.onchange = function(e) {
      const file = e.target.files[0]
      if(isImg(file.name)) {
        if(imgUrl) {
          removeObjectURL()
          result = []
          resultDiv.innerHTML = ''
        }
        imgUrl = getObjectURL(file)
        drawToCanvas()
      }
    }

  </script>
</body>
</html>