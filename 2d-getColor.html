<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <link rel="icon" href="favicon.jpg">
  <title>2d-getColor</title>
  <style>
    canvas {
      width: 0px;
    }
    .result {
      display: grid;
      grid-template-columns: repeat(auto-fill,minmax(320px,1fr));
      gap: 4px;
    }
    .result > img {
      grid-row-start: 1;
      grid-row-end: 10;
    }
    .result > div:nth-child(2)::before {
      content: '这个是平均色↓';
      display: block;
      position: relative;
      left: 0; top: -24px;
    }
  </style>
</head>
<body>
  <h1>中位切割法获取图片颜色主要颜色</h1>
  <pre>
    使用中位切分法(将所有像素映射到三维坐标上(r,g,b))
    获取图片所有像素  canvas 的 getImageData
    计算边界 rmax gmax bmax rmin gmin bmin, 代表包裹像素分布区域的长宽高
    从维度最大的轴来做中位切割
    按照上述重复切割
    //按色块所包含像素数量从大到小排
    //画入canvas是 200*200, 所以总像素为4w
    //色块数量按 2 4 8 16 来, 目前默认为8, 修改为不切割所有色块,选择当前像素量最大的块切割,一直到数量满足要求
    计算所有色块的平均值作为当前色块的代表色
    //最后,将结果色块从rgb转为Lab,计算差值,差值小于40定义为相似颜色,合并颜色,获取到图片主色调, 并不靠谱和视觉上仍有冲突
    //主色取切成两块时,大的那块平均色
    <a href="https://blog.csdn.net/yuzi_lixiaoge/article/details/52781506">rgb 转 Lab</a>
    <a href="http://www.colormine.org/delta-e-calculator">颜色相似度计算</a>
    <a href="https://stackoverflow.com/questions/5392061/algorithm-to-check-similarity-of-colors">关于颜色相似的处理链接</a> 
  </pre>
  <input type="file">
  <select name="count" id="count">
    <option value="4" selected>4</option>
    <option value="5">5</option>
    <option value="6">6</option>
    <option value="7">7</option>
    <option value="8">8</option>
    <option value="9">9</option>
    <option value="10">10</option>
    <option value="11">11</option>
    <option value="12">12</option>
    <option value="13">13</option>
    <option value="14">14</option>
    <option value="15">15</option>
    <option value="16">16</option>
  </select>
  <canvas width="300" height="200">如果看到这句话说明浏览器不支持canvas</canvas>
  <div class="result"></div>
  <script>

    let count = 4

    let result = []

    let colors = []   //颜色

    const input = document.getElementsByTagName('input')[0]

    const select = document.getElementById('count')

    const ctx = document.getElementsByTagName('canvas')[0].getContext('2d')

    const resultDiv = document.getElementsByTagName('div')[0]

    let imgUrl

    //清除选中的文件
    function removeFile() {
      input.outerHTML = input.outerHTML
    }

    //使用createObjectURl来获取图片地址(也可以使用FileReader)
    function getObjectURL(file) {
      let url = null ;
      if (window.createObjectURL!=undefined) { // basic
        url = window.createObjectURL(file) 
      } else if (window.URL!=undefined) { // mozilla(firefox)
        url = window.URL.createObjectURL(file) 
      } else if (window.webkitURL!=undefined) { // webkit or chrome
        url = window.webkitURL.createObjectURL(file) 
      }
	    return url 
    }

    //移除生成的图片地址
    function removeObjectURL() {
      if (window.revokeObjectURL!=undefined) { // basic
        imgUrl = window.revokeObjectURL(imgUrl) 
      } else if (window.URL!=undefined) { // mozilla(firefox)
        imgUrl = window.URL.revokeObjectURL(imgUrl) 
      } else if (window.webkitURL!=undefined) { // webkit or chrome
        imgUrl = window.webkitURL.revokeObjectURL(imgUrl) 
      }
    }

    //画到canvas里
    function drawToCanvas() {
      const img = new Image(320)
      img.onload = function() {
        ctx.drawImage(img,0,0,200,200)
        const pixels = getPixels()
        slicePixels(pixels) 
        repeatSlicePixels(result.length)
        // console.log(result)
        result.sort((a,b) => b.length - a.length) //降序
        const obj = {r:0,g:0,b:0}
        result.forEach(data => {
          const [r,g,b] = calColor(data)
          createDiv(`rgb(${r},${g},${b})`)
        })
        //将颜色转换成Lab,进行deltaE计算,差值目前决定在20之内
        // console.log(colors)
        // combineColors()
        // const mainColor = getMainColor()
        // // createDiv(mainColor)
      }
      img.src = imgUrl
      resultDiv.appendChild(img)
    }

    //获取主色调 
    function getMainColor() {
      let max = 0, maxIndex = 0
      colors.forEach((color,index) => {
        if(color['index'] >= max) {
          max = color['index']
          maxIndex = index
        }
      })
      const len = colors[maxIndex]['index'] + 1
      const r = colors[maxIndex]['rgb'][0] / len
      const g = colors[maxIndex]['rgb'][1] / len
      const b = colors[maxIndex]['rgb'][2] / len
      return `rgb(${r},${g},${b})`
    }

    //合并颜色
    function combineColors() {
      for(let i = 0;i < colors.length;i++) {
        for(let j = i + 1;j < colors.length;j++) {
          const diff = deltaE(colors[i]['lab'],colors[j]['lab'])
          if(diff <= 40) {
            colors[i]['len'] += colors[j]['len']
            colors[i]['rgb'][0] += colors[j]['rgb'][0]
            colors[i]['rgb'][1] += colors[j]['rgb'][1]
            colors[i]['rgb'][2] += colors[j]['rgb'][2]
            colors[i]['index']++
            colors.splice(j,1)
          }
        }
      }
    }

    //deltaE
    function deltaE(color1,color2) {
      // (l2-l1)
      const l = Math.pow(color2[0] - color1[0],2)
      const a = Math.pow(color2[1] - color1[1],2)
      const b = Math.pow(color2[2] - color1[1],2)
      return Math.sqrt(l + a + b)
    }

    //rgb 转 Lab
    function rgbToLab(r, g, b) {
      r /= 255, g /= 255, b /= 255;
      if ( r > 0.04045 ){
			  r = Math.pow(( r + 0.055 ) / 1.055, 2.4);
      } else {
        r = r / 12.92;
      }
      if ( g > 0.04045 ){
        g = Math.pow(( g + 0.055 ) / 1.055, 2.4);
      } else {
        g = g / 12.92;
      }
      if ( b > 0.04045 ){
        b = Math.pow(( b + 0.055 ) / 1.055, 2.4);
      } else {
        b = b / 12.92;
      }
      // sRGB
      let X = r * 0.436052025 + g * 0.385081593 + b * 0.143087414;
      let Y = r * 0.222491598 + g * 0.716886060 + b * 0.060621486;
      let Z = r * 0.013929122 + g * 0.097097002 + b * 0.714185470;
      // XYZ range: 0~100
      X = X * 100.000;
      Y = Y * 100.000;
      Z = Z * 100.000;
      // Reference White Point
      let ref_X = 96.4221;
      let ref_Y = 100.000;
      let ref_Z = 82.5211;
      X = X / ref_X;
      Y = Y / ref_Y;
      Z = Z / ref_Z;
      // Lab
      if (X > 0.008856){
        X = Math.pow(X, 1/3.000);
      } else {
        X = ( 7.787 * X ) + ( 16 / 116.000 );
      }
      if (Y > 0.008856){
        Y = Math.pow(Y, 1/3.000);
      } else {
        Y = ( 7.787 * Y ) + ( 16 / 116.000 );
      }
      if (Z > 0.008856){
        Z = Math.pow(Z, 1/3.000);
      } else {
        Z = ( 7.787 * Z ) + ( 16 / 116.000 );
      }
  
      let lab_L = ( 116.000 * Y ) - 16.000;
      let lab_A = 500.000 * ( X - Y );
      let lab_B = 200.000 * ( Y - Z );
  
      return [lab_L, lab_A , lab_B];

    }

    //生成色块
    function createDiv(bgColor) {
      const div = document.createElement('div')
      Object.assign(div.style,{
        backgroundColor: bgColor,
        height: '50px',
      })
      resultDiv.appendChild(div)
    }

    //切割像素
    function slicePixels(pixels) {
      let rmax, rmin, gmax, gmin, bmax, bmin
      pixels.forEach(pixel => {
        const r = pixel['r']
        const g = pixel['g']
        const b = pixel['b']
        rmax = getMaxBoundary(rmax,r)
        rmin = getMinBoundary(rmin,r)
        gmax = getMaxBoundary(gmax,g) 
        gmin = getMinBoundary(gmin,g)
        bmax = getMaxBoundary(bmax,b) 
        bmin = getMinBoundary(bmin,b)
      })
      const median = getMedian(rmax,rmin,gmax,gmin,bmax,bmin)
      const block1 = [], block2 = []
      pixels.forEach(pixel => {
        if(pixel[median['key']] >= median['value']) {
          block1.push(pixel)
        }else{
          block2.push(pixel)
        }
      })
      result.push(block1,block2)
    }

    //重复切割
    function repeatSlicePixels(len) {
      if(len < count) {
        // result.forEach(data => slicePixels(data)) //等价于for(let i = 0;i<len-1;i++)
        // result.splice(0,len)
        // repeatSlicePixels(result.length)
        // 找到像素最多的那块切割
        let max = 0, maxIndex
        result.forEach((block,index) => {
          // console.log(block.v,index)
          if(block.length >= max) {
            max = block.length
            maxIndex = index
          }
        })
        // console.log(maxIndex)
        slicePixels(result[maxIndex])
        if(len === 2) {
          let [r,g,b] = calColor(result[maxIndex])
          if(isDark(r,g,b)) {
            r += 15
            g += 15
            b += 15
          }
          if(isLight(r,g,b)) {
            r -= 15
            g -= 15
            b -= 15
          }
          document.body.style.backgroundColor = `rgba(${r},${g},${b},.9)`
        }
        result.splice(maxIndex,1)
        repeatSlicePixels(result.length)
      }
    }

    //过黑 50
    function isDark(r,g,b) {
      if(r < 50 && g < 50 && b < 50) {
        return true
      }else{
        return false
      }
    }
    //过白
    function isLight(r,g,b) {
      if(r > 205 && g < 205 && b > 205) {
        return true
      }else{
        return false
      }
    }
    //计算平均颜色
    function calColor(data) {
      let accR = 0, accG = 0, accB = 0
      let len = data.length
      data.forEach(item => {
        accR += item['r']
        accG += item['g']
        accB += item['b']
      })
      const r = Math.round(accR/len)
      const g = Math.round(accG/len)
      const b = Math.round(accB/len)
      return [r,g,b]
    }

    //获取像素点
    function getPixels() {
      const { data } = ctx.getImageData(0,0,200,200)
      // const pixel = {r,g,b,a}
      const pixels = []
      // const pixelObj = {}
      let r = 0, g = 0, b = 0
      for(let i = 0;i < data.length;i += 4) {
        const pixel = {}
        r += pixel['r'] = data[i]
        g += pixel['g'] = data[i+1]
        b += pixel['b'] = data[i+2]
        pixels.push(pixel)
      }
      const len = pixels.length
      r = Math.round(r/len)
      g = Math.round(g/len)
      b = Math.round(b/len)
      const bgColor = `rgb(${r},${g},${b})`

      createDiv(bgColor) //平均色
      return pixels
    }

    //获取边界(最大最小rgb)
    function getMaxBoundary(max,diff) {
      if(max === undefined) return diff
      return Math.max(max,diff)
    }
    function getMinBoundary(min,diff) {
      if(min === undefined) return diff
      return Math.min(min,diff)
    }

    //获取中位线
    function getMedian(rmax,rmin,gmax,gmin,bmax,bmin) {
      const r = rmax - rmin
      const g = gmax - gmin
      const b = bmax - bmin
      const max = Math.max(r,g,b)
      if(r === max) return {key:'r',value:(rmax + rmin)/2}
      if(g === max) return {key:'g',value:(gmax + gmin)/2}
      if(b === max) return {key:'b',value:(bmax + bmin)/2}
    }

    //判断是否图片
    function isImg(fileName) {
      const pattern = /\.(jpg|jpeg|png|GIF|JPG|PNG)$/
      if (pattern.test(fileName) ) return  true
      alert('请选择图片文件')
	    return false
    }

    //选择图片处理函数
    function handleImgChange() {
      const file = input.files[0]
      if(!file) return    //取消选择
      if(isImg(file.name)) {
        if(imgUrl) {
          removeObjectURL()
          result = []
          colors = []
          resultDiv.innerHTML = ''
        }
        imgUrl = getObjectURL(file)
        drawToCanvas()
      }
    }

    input.onchange = handleImgChange

    select.onchange = function() {
      count = Number(select.value)
      if(imgUrl) handleImgChange()
    }

  </script>
</body>
</html>
